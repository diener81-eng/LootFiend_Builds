<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Lootborn Build Tracker</title>
  <style>
    :root{
      --bg:#0f1115;
      --panel:#1a1d24;
      --text:#e6e6e6;
      --muted:#b5b5b5;
      --border:#333;
      --ok:#7CFC98;
      --bad:#ff7a7a;
      --warn:#ffd27a;
    }
    body{font-family:system-ui,-apple-system,BlinkMacSystemFont,sans-serif;background:var(--bg);color:var(--text);margin:0;padding:20px;}
    h1,h2,h3{margin:0 0 10px;}
    .container{max-width:1200px;margin:auto;}
    .topbar{display:flex;gap:12px;flex-wrap:wrap;align-items:baseline;justify-content:space-between;margin-bottom:12px;}
    .small{color:var(--muted);font-size:0.92em;}

    .row{display:grid;grid-template-columns:1.1fr 0.9fr;gap:14px;align-items:start;}
    @media (max-width: 980px){.row{grid-template-columns:1fr;}}

    .card{background:var(--panel);padding:14px;border-radius:12px;border:1px solid rgba(255,255,255,0.04);}
    .hint{color:var(--muted);font-size:0.92em;line-height:1.3;}

    .inv-grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(220px,1fr));gap:12px;margin-top:10px;}
    .slot{background:rgba(0,0,0,0.20);border:1px solid rgba(255,255,255,0.08);border-radius:12px;padding:10px;}
    .slot label{display:block;font-weight:700;margin-bottom:6px;}
    textarea{width:100%;box-sizing:border-box;background:var(--bg);color:var(--text);border:1px solid var(--border);border-radius:10px;padding:10px;min-height:88px;resize:vertical;outline:none;}

    button{cursor:pointer;background:#222738;color:var(--text);border:1px solid rgba(255,255,255,0.10);border-radius:10px;padding:10px 12px;font-weight:700;}
    button:hover{filter:brightness(1.08);} 
    button:active{transform:translateY(1px);} 
    .btn-row{display:flex;gap:10px;flex-wrap:wrap;margin-top:10px;}

    .toggle-row{display:flex;gap:10px;flex-wrap:wrap;align-items:center;margin-top:10px;}
    .toggle-row label{display:inline-flex;gap:8px;align-items:center;color:var(--muted);font-size:0.92em;user-select:none;}

    .build{background:rgba(0,0,0,0.20);border:1px solid rgba(255,255,255,0.08);padding:14px;border-radius:12px;margin-bottom:12px;}
    .meta{color:var(--muted);font-size:0.92em;margin-top:-6px;margin-bottom:8px;}
    .progress{font-weight:900;}
    .ok{color:var(--ok);font-weight:900;}
    .bad{color:var(--bad);font-weight:900;}
    .warn{color:var(--warn);font-weight:900;}
    details{margin-top:10px;}
    summary{cursor:pointer;color:var(--muted);}
    ul{margin:8px 0 0 18px;padding:0;}
    li{margin:4px 0;}
  </style>
</head>
<body>
  <div class="container">
    <div class="topbar">
      <h1>Lootborn Build Tracker v1.2</h1>
      <div class="small">Saves in your browser (no login). Inventory is separated by slot.</div>
    </div>

    <div class="row">
      <div class="card">
        <h2>Your Inventory</h2>
        <div class="hint">
          Check the items you own. This list is auto-generated from all items used in the builds (including substitutes).
          Your selections save automatically in your browser.
        </div>

        <div class="btn-row">
          <button id="saveBtn">Save now</button>
          <button id="clearBtn" title="Clears all saved inventory">Clear inventory</button>
        </div>

        <div class="inv-grid" id="invGrid"></div>
      </div>

      <div class="card">
        <h2>Builds you are closest to</h2>
        <div class="toggle-row">
          <label><input type="checkbox" id="showPlayableOnly" /> Show playable only</label>
          <label><input type="checkbox" id="sortByOptimal" checked /> Sort by optimal percent</label>
        </div>
        <div id="buildResults" style="margin-top:12px;"></div>
      </div>
    </div>
  </div>

  <script>
  // Version marker: bump this each revision so you can confirm the live site updated.
  const VERSION = "1.2";

  window.addEventListener("DOMContentLoaded", () => {
    const slots = [
      "weapon","helmet","cuirass","belt","greaves","pauldron",
      "bracers","gauntlet","boots","necklace","amulet","ring"
    ];

    // Builds: add more objects here as you paste them in.
    const builds = [
      {
        class: "Arcanist",
        coreSkill: "Fireball",
        build: "Iceflame",
        variant: "PvE",
        gear: {
          weapon: "Fate Intertwined",
          helmet: "Evil Spirit Skull",
          cuirass: "Void Cavity",
          belt: "Resurrection",
          greaves: "Void Hip",
          pauldron: "Fairy Whisper",
          bracers: "Dragon Roar Mark",
          gauntlet: "Void Arm",
          boots: "Void Shin",
          necklace: "Balance Chain",
          amulet: "End's Return",
          ring: "Swift Shadow Finger"
        },
        alternatives: {
          boots: ["Planar Shortcut"],
          amulet: ["Overflow Amulet"],
          belt: ["Viper Bond"]
        }
      },
      {
        class: "Arcanist",
        coreSkill: "Fireball",
        build: "Iceflame",
        variant: "Ancient God PvE",
        gear: {
          weapon: "Ancient God's Call",
          helmet: "Dragon Claw Visage",
          cuirass: "Dragon Bone Armor",
          belt: "Dragon Soul Smile",
          greaves: "Dragon Spine Leggings",
          pauldron: "Fairy Whisper",
          bracers: "Dragon Roar Mark",
          gauntlet: "Dragon Fury Grip",
          boots: "Dragon Hyun Walker",
          necklace: "Temporal Pendant",
          amulet: "End's Return",
          ring: "Swift Shadow Finger"
        },
        alternatives: {}
      }
    ];

    const STORAGE_KEY = "lootborn_inventory_checkboxes_v1";

    function titleCase(s) {
      if (!s) return "";
      return s.charAt(0).toUpperCase() + s.slice(1);
    }

    function escapeHtml(str) {
      return String(str)
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;")
        .replaceAll('"', "&quot;")
        .replaceAll("'", "&#039;");
    }

    // ---- Build the item catalog (by slot) from the builds ----
    function buildItemCatalog() {
      const bySlot = {};
      for (const slot of slots) bySlot[slot] = [];

      for (const b of builds) {
        for (const slot of slots) {
          const req = b.gear && b.gear[slot];
          if (req) bySlot[slot].push(req);
          const alts = (b.alternatives && b.alternatives[slot]) ? b.alternatives[slot] : [];
          for (const a of alts) bySlot[slot].push(a);
        }
      }

      // unique + sort
      const uniqSorted = {};
      for (const slot of slots) {
        const seen = new Set();
        const out = [];
        for (const it of bySlot[slot]) {
          const item = String(it || "").trim();
          if (!item) continue;
          if (seen.has(item)) continue;
          seen.add(item);
          out.push(item);
        }
        out.sort((a, b) => a.localeCompare(b));
        uniqSorted[slot] = out;
      }

      return uniqSorted;
    }

    const catalog = buildItemCatalog();

    // ---- Inventory state (by slot: Set of owned items) ----
    function emptyInventory() {
      const inv = {};
      for (const slot of slots) inv[slot] = new Set();
      return inv;
    }

    function loadInventory() {
      const inv = emptyInventory();
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return inv;
        const obj = JSON.parse(raw);
        for (const slot of slots) {
          const arr = obj && obj[slot];
          if (Array.isArray(arr)) {
            for (const it of arr) inv[slot].add(String(it).trim());
          }
        }
      } catch (e) {
        // ignore
      }
      return inv;
    }

    function saveInventory(inv) {
      const obj = {};
      for (const slot of slots) obj[slot] = Array.from(inv[slot]);
      localStorage.setItem(STORAGE_KEY, JSON.stringify(obj));
    }

    let inventory = loadInventory();

    function clearInventory() {
      inventory = emptyInventory();
      saveInventory(inventory);
      renderInventory();
      renderBuilds();
    }

    // ---- Scoring ----
    function buildScore(build) {
      const missing = [];
      const substitutes = [];

      let requiredCount = 0;
      let optimalOwned = 0;
      let playable = true;

      for (const slot of slots) {
        const required = build.gear && build.gear[slot];
        if (!required) continue;
        requiredCount++;

        if (inventory[slot].has(required)) {
          optimalOwned++;
          continue;
        }

        const alts = (build.alternatives && build.alternatives[slot]) ? build.alternatives[slot] : [];
        const ownedAlt = alts.find(a => inventory[slot].has(a));

        if (ownedAlt) {
          substitutes.push(`${titleCase(slot)} → ${ownedAlt} (missing ${required})`);
        } else {
          playable = false;
          missing.push(`${titleCase(slot)}: ${required}`);
        }
      }

      const optimalPct = requiredCount ? Math.round((optimalOwned / requiredCount) * 100) : 0;
      return { requiredCount, optimalOwned, optimalPct, playable, missing, substitutes };
    }

    function buildDetailsHtml(score) {
      let html = `<details><summary>Details</summary>`;

      if (score.missing.length) {
        html += `<div style="margin-top:8px;"><span class="bad">Missing</span><ul>`;
        for (const m of score.missing) html += `<li>${escapeHtml(m)}</li>`;
        html += `</ul></div>`;
      }

      if (score.substitutes.length) {
        html += `<div style="margin-top:8px;"><span class="warn">Substitutes</span><ul>`;
        for (const s of score.substitutes) html += `<li>${escapeHtml(s)}</li>`;
        html += `</ul></div>`;
      }

      html += `</details>`;
      return html;
    }

    function renderBuilds() {
      const out = document.getElementById("buildResults");
      const playableOnly = document.getElementById("showPlayableOnly").checked;
      const sortByOptimal = document.getElementById("sortByOptimal").checked;

      let rows = builds.map(b => ({ b, s: buildScore(b) }));
      if (playableOnly) rows = rows.filter(r => r.s.playable);
      if (sortByOptimal) rows.sort((a, b) => b.s.optimalPct - a.s.optimalPct);

      out.innerHTML = "";

      if (!rows.length) {
        out.innerHTML = `<div class="hint">No builds match your current inventory.</div>`;
        return;
      }

      for (const { b, s } of rows) {
        const div = document.createElement("div");
        div.className = "build";

        const playableLabel = s.playable
          ? `<span class="ok">Playable</span>`
          : `<span class="bad">Not playable</span>`;

        const detailsNeeded = s.missing.length || s.substitutes.length;

        div.innerHTML = `
          <h3>${escapeHtml(b.build)} – ${escapeHtml(b.variant)}</h3>
          <div class="meta">${escapeHtml(b.class)} • ${escapeHtml(b.coreSkill)} • ${s.optimalOwned}/${s.requiredCount} optimal</div>
          <div class="progress">Optimal: ${s.optimalPct}%</div>
          <div style="margin-top:6px;">${playableLabel}</div>
          ${detailsNeeded ? buildDetailsHtml(s) : ""}
        `;

        out.appendChild(div);
      }
    }

    // ---- Inventory UI (checkbox database) ----
    function renderInventory() {
      const grid = document.getElementById("invGrid");
      grid.innerHTML = "";

      for (const slot of slots) {
        const wrap = document.createElement("div");
        wrap.className = "slot";

        const items = catalog[slot];
        const countOwned = inventory[slot].size;

        let html = `<label>${titleCase(slot)} <span class="small">(${countOwned} owned)</span></label>`;

        if (!items.length) {
          html += `<div class="hint">No items loaded for this slot yet.</div>`;
          wrap.innerHTML = html;
          grid.appendChild(wrap);
          continue;
        }

        html += `<div>`;
        for (const item of items) {
          const id = `cb_${slot}_${item}`.replaceAll(" ", "_").replaceAll("'", "");
          const checked = inventory[slot].has(item) ? "checked" : "";
          html += `
            <div style="display:flex; gap:10px; align-items:flex-start; margin:6px 0;">
              <input type="checkbox" id="${escapeHtml(id)}" data-slot="${escapeHtml(slot)}" data-item="${escapeHtml(item)}" ${checked} />
              <label for="${escapeHtml(id)}" style="margin:0; font-weight:600; cursor:pointer;">${escapeHtml(item)}</label>
            </div>
          `;
        }
        html += `</div>`;

        wrap.innerHTML = html;
        grid.appendChild(wrap);
      }

      // Wire checkbox events
      grid.querySelectorAll("input[type=checkbox]").forEach(cb => {
        cb.addEventListener("change", (e) => {
          const slot = e.target.getAttribute("data-slot");
          const item = e.target.getAttribute("data-item");
          if (!slot || !item) return;

          if (e.target.checked) inventory[slot].add(item);
          else inventory[slot].delete(item);

          saveInventory(inventory);
          // update counts and build results
          renderBuilds();
          // lightweight count refresh: rerender only this slot header would be nicer, but keep simple
          renderInventory();
        });
      });
    }

    // ---- Wire up controls ----
    document.getElementById("clearBtn").addEventListener("click", () => {
      if (confirm("Clear your saved inventory?")) clearInventory();
    });

    document.getElementById("saveBtn").addEventListener("click", () => {
      saveInventory(inventory);
      renderBuilds();
    });

    document.getElementById("showPlayableOnly").addEventListener("change", renderBuilds);
    document.getElementById("sortByOptimal").addEventListener("change", renderBuilds);

    // Init
    renderInventory();
    renderBuilds();
  });
</script>
</body>
</html>
