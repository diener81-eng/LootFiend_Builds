<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Lootborn Build Tracker</title>
  <style>
    :root{
      --bg:#0f1115;
      --panel:#1a1d24;
      --text:#e6e6e6;
      --muted:#b5b5b5;
      --border:#333;
      --ok:#7CFC98;
      --bad:#ff7a7a;
      --warn:#ffd27a;
    }
    body{font-family:system-ui,-apple-system,BlinkMacSystemFont,sans-serif;background:var(--bg);color:var(--text);margin:0;padding:20px;}
    h1,h2,h3{margin:0 0 10px;}
    .container{max-width:1200px;margin:auto;}
    .topbar{display:flex;gap:12px;flex-wrap:wrap;align-items:baseline;justify-content:space-between;margin-bottom:12px;}
    .small{color:var(--muted);font-size:0.92em;}
    .desc{margin:12px 0 14px; line-height:1.35; font-size:0.98em;}
    .desc b{color:var(--warn);} 

    .row{display:grid;grid-template-columns:1.1fr 0.9fr;gap:14px;align-items:start;}
    @media (max-width: 980px){.row{grid-template-columns:1fr;}}

    .card{background:var(--panel);padding:14px;border-radius:12px;border:1px solid rgba(255,255,255,0.04);}
    .hint{color:var(--muted);font-size:0.92em;line-height:1.3;}

    .inv-grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(220px,1fr));gap:12px;margin-top:10px;}
    .slot{background:rgba(0,0,0,0.20);border:1px solid rgba(255,255,255,0.08);border-radius:12px;padding:10px;}
    .slot label{display:block;font-weight:700;margin-bottom:6px;}
    textarea{width:100%;box-sizing:border-box;background:var(--bg);color:var(--text);border:1px solid var(--border);border-radius:10px;padding:10px;min-height:88px;resize:vertical;outline:none;}

    button{cursor:pointer;background:#222738;color:var(--text);border:1px solid rgba(255,255,255,0.10);border-radius:10px;padding:10px 12px;font-weight:700;}
    button:hover{filter:brightness(1.08);} 
    button:active{transform:translateY(1px);} 
    .btn-row{display:flex;gap:10px;flex-wrap:wrap;margin-top:10px;}

    .toggle-row{display:flex;gap:10px;flex-wrap:wrap;align-items:center;margin-top:10px;}
    .toggle-row label{display:inline-flex;gap:8px;align-items:center;color:var(--muted);font-size:0.92em;user-select:none;}

    .build{background:rgba(0,0,0,0.20);border:1px solid rgba(255,255,255,0.08);padding:14px;border-radius:12px;margin-bottom:12px;}
    .meta{color:var(--muted);font-size:0.92em;margin-top:-6px;margin-bottom:8px;}
    .progress{font-weight:900;}
    .ok{color:var(--ok);font-weight:900;}
    .bad{color:var(--bad);font-weight:900;}
    .warn{color:var(--warn);font-weight:900;}
    details{margin-top:10px;}
    summary{cursor:pointer;color:var(--muted);}
    ul{margin:8px 0 0 18px;padding:0;}
    li{margin:4px 0;}
  </style>
</head>
<body>
  <div class="container">
    <div class="topbar">
      <h1>Lootborn Build Tracker v2.3</h1>
      <div class="small">Saves in your browser (no login). Arcanist and Savage inventories are stored separately, because their stash items are different.</div>
    </div>

    

    <div class="row">
      <div class="card">
        <h2>Your Inventory</h2>
        <div class="hint">
          Check the items you own. This list is auto-generated from all items used in the builds (including substitutes).
          Your selections save automatically in your browser.
        </div>

        <div class="btn-row">
          <button id="saveBtn">Save now</button>
          <button id="clearBtn" title="Clears all saved inventory">Clear inventory</button>
        </div>

        <div class="inv-grid" id="invGrid"></div>
      </div>

      <div class="card">
        <h2>Builds you are closest to</h2>
        <div class="toggle-row">
          <label><input type="checkbox" id="showPlayableOnly" /> Show playable only</label>
          <label><input type="checkbox" id="sortByOptimal" checked /> Sort by optimal percent</label>
          <label>Class
            <select id="classFilter" style="margin-left:6px; background: var(--bg); color: var(--text); border: 1px solid var(--border); border-radius: 8px; padding: 6px 8px;">
              <option value="Arcanist" selected>Arcanist</option>
              <option value="Savage">Savage</option>
            </select>
          </label>
        </div>
        <div id="buildResults" style="margin-top:12px;"></div>
      </div>
    </div>
  </div>

  <script>
  // Version marker: bump this each revision so you can confirm the live site updated.
  const VERSION = "2.3";

  window.addEventListener("DOMContentLoaded", () => {
    const slots = [
      "weapon","helmet","cuirass","belt","greaves","pauldron",
      "bracers","gauntlet","boots","necklace","amulet","ring"
    ];

    const WIKI_BASE = "https://lootbornwarriors.miraheze.org/wiki/";

    // --- Name normalization (aliases) ---
    // Canonical spellings go on the RIGHT side.
    const NAME_ALIASES = {
      "ancient god call": "Ancient God's Call",
      "ancient gods call": "Ancient God's Call",
      "ancient god's call": "Ancient God's Call",
      "pack binding": "Pact Binding",
      "dragon hyun walker": "Dragon Hymn Walker"
    };

    function collapseSpaces(s) {
      let out = String(s || "");
      while (out.includes("  ")) out = out.replaceAll("  ", " ");
      return out;
    }

    function normalizeKey(s) {
      return collapseSpaces(String(s || "").trim().replaceAll("’", "'")).toLowerCase();
    }

    function normalizeItemName(name) {
      const raw = collapseSpaces(String(name || "").trim().replaceAll("’", "'"));
      if (!raw) return "";
      const key = normalizeKey(raw);
      return NAME_ALIASES[key] || raw;
    }

    // --- Separate storage per class (Arcanist vs Savage) ---
    const STORAGE_KEY_PREFIX = "lootborn_inventory_v3";
    function storageKeyFor(cls) {
      return STORAGE_KEY_PREFIX + "_" + String(cls || "").toLowerCase();
    }

    // Builds: add more objects here as you paste them in.
    const builds = [
      $&
      ,{
        class: "Savage",
        coreSkill: "Bladestorm",
        build: "Thunder",
        variant: "PvE",
        gear: {
          weapon: "Tribal Reverence",
          helmet: "Crown of Madness",
          cuirass: "Desolate Cuirass",
          belt: "Desolate Belt",
          greaves: "Desolate Greaves",
          pauldron: "Demonbane Pauldron",
          bracers: "Might of Fury",
          gauntlet: "Ancestral Legacy",
          boots: "Desolate Boots",
          necklace: "Ironblood Soul",
          amulet: "Bloodhowl Charm",
          ring: "Dragon's Might"
        },
        alternatives: {
          cuirass: ["Conqueror Soul"],
          gauntlet: ["Ruler's Gauntlets"],
          amulet: ["Eye of Thunder"]
        }
      },
      {
        class: "Savage",
        coreSkill: "Bladestorm",
        build: "Thunder",
        variant: "PvP",
        gear: {
          weapon: "Ancestor",
          helmet: "Desolate Helm",
          cuirass: "Desolate Cuirass",
          belt: "Desolate Belt",
          greaves: "Desolate Greaves",
          pauldron: "Demonbane Pauldron",
          bracers: "Might of Fury",
          gauntlet: "Ruler's Gauntlets",
          boots: "Bloodclaw Sabatons",
          necklace: "Ironblood Soul",
          amulet: "Bloodhowl Charm",
          ring: "Dragon's Might"
        },
        alternatives: {
          gauntlet: ["Gladiator's Force"]
        }
      }
    ];

    function escapeHtml(str) {
      return String(str)
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;")
        .replaceAll('"', "&quot;")
        .replaceAll("'", "&#039;");
    }

    function titleCase(s) {
      if (!s) return "";
      return s.charAt(0).toUpperCase() + s.slice(1);
    }

    function wikiUrlForBuild(buildName) {
      const slug = String(buildName || "").trim().split(" ").filter(Boolean).join("_");
      return WIKI_BASE + encodeURIComponent(slug);
    }

    function getClassFilter() {
      const el = document.getElementById("classFilter");
      return el ? el.value : "Arcanist";
    }

    function getFilteredBuilds() {
      const cf = getClassFilter();
      return builds.filter(b => b.class === cf);
    }

    function emptyInventory() {
      const inv = {};
      for (const slot of slots) inv[slot] = new Set();
      return inv;
    }

    function loadInventory(cls) {
      const inv = emptyInventory();
      try {
        const raw = localStorage.getItem(storageKeyFor(cls));
        if (!raw) return inv;
        const obj = JSON.parse(raw);
        for (const slot of slots) {
          const arr = obj && obj[slot];
          if (Array.isArray(arr)) {
            for (const it of arr) inv[slot].add(normalizeItemName(it));
          }
        }
      } catch (e) {}
      return inv;
    }

    function saveInventory(inv, cls) {
      const obj = {};
      for (const slot of slots) obj[slot] = Array.from(inv[slot]);
      localStorage.setItem(storageKeyFor(cls), JSON.stringify(obj));
    }

    let activeClass = getClassFilter();
    let inventory = loadInventory(activeClass);

    function clearInventory() {
      inventory = emptyInventory();
      saveInventory(inventory, activeClass);
      renderInventory();
      renderBuilds();
    }

    function buildItemCatalog(filteredBuilds) {
      const bySlot = {};
      for (const slot of slots) bySlot[slot] = [];

      for (const b of filteredBuilds) {
        for (const slot of slots) {
          const req = b.gear && b.gear[slot];
          if (req) bySlot[slot].push(normalizeItemName(req));
          const alts = (b.alternatives && b.alternatives[slot]) ? b.alternatives[slot] : [];
          for (const a of alts) bySlot[slot].push(normalizeItemName(a));
        }
      }

      const uniqSorted = {};
      for (const slot of slots) {
        const seen = new Set();
        const out = [];
        for (const it of bySlot[slot]) {
          const item = normalizeItemName(it);
          if (!item) continue;
          if (seen.has(item)) continue;
          seen.add(item);
          out.push(item);
        }
        out.sort((a, b) => a.localeCompare(b));
        uniqSorted[slot] = out;
      }

      return uniqSorted;
    }

    function buildScore(build) {
      let requiredCount = 0;
      let optimalOwned = 0;
      let playable = true;

      for (const slot of slots) {
        const requiredRaw = build.gear && build.gear[slot];
        if (!requiredRaw) continue;
        const required = normalizeItemName(requiredRaw);
        requiredCount++;

        if (inventory[slot].has(required)) {
          optimalOwned++;
          continue;
        }

        const altsRaw = (build.alternatives && build.alternatives[slot]) ? build.alternatives[slot] : [];
        const ownedAlt = altsRaw.map(normalizeItemName).find(a => inventory[slot].has(a));
        if (!ownedAlt) playable = false;
      }

      const optimalPct = requiredCount ? Math.round((optimalOwned / requiredCount) * 100) : 0;
      return { requiredCount, optimalOwned, optimalPct, playable };
    }

    function buildGearBreakdown(build) {
      const rows = [];
      for (const slot of slots) {
        const reqRaw = build.gear && build.gear[slot];
        if (!reqRaw) continue;
        const req = normalizeItemName(reqRaw);

        const hasReq = inventory[slot].has(req);
        const altsRaw = (build.alternatives && build.alternatives[slot]) ? build.alternatives[slot] : [];
        const ownedAlt = altsRaw.map(normalizeItemName).find(a => inventory[slot].has(a));

        rows.push({
          slot,
          required: req,
          status: hasReq ? "owned" : (ownedAlt ? "sub" : "missing"),
          substitute: ownedAlt || ""
        });
      }
      return rows;
    }

    function gearDetailsHtml(build) {
      const rows = buildGearBreakdown(build);
      const wiki = wikiUrlForBuild(build.build);

      let html = '<details><summary>Build details</summary>';
      html += '<div style="margin-top:8px; display:flex; gap:10px; flex-wrap:wrap; align-items:center;">';
      html += '<a href="' + escapeHtml(wiki) + '" target="_blank" rel="noopener" style="color: var(--warn); text-decoration: none; font-weight: 800;">Open wiki page</a>';
      html += '<span class="small">(opens in new tab)</span>';
      html += '</div>';

      html += '<div style="margin-top:10px;"><ul>';
      for (const r of rows) {
        if (r.status === "owned") {
          html += '<li><span class="ok">✓</span> <b>' + escapeHtml(titleCase(r.slot)) + '</b>: ' + escapeHtml(r.required) + '</li>';
        } else if (r.status === "sub") {
          html += '<li><span class="warn">~</span> <b>' + escapeHtml(titleCase(r.slot)) + '</b>: missing ' + escapeHtml(r.required) + ' — using ' + escapeHtml(r.substitute) + '</li>';
        } else {
          html += '<li><span class="bad">✗</span> <b>' + escapeHtml(titleCase(r.slot)) + '</b>: ' + escapeHtml(r.required) + '</li>';
        }
      }
      html += '</ul></div></details>';
      return html;
    }

    function renderBuilds() {
      const out = document.getElementById("buildResults");
      const playableOnly = document.getElementById("showPlayableOnly").checked;
      const sortByOptimal = document.getElementById("sortByOptimal").checked;

      const filteredBuilds = getFilteredBuilds();
      if (!filteredBuilds.length) {
        out.innerHTML = '<div class="hint">No ' + escapeHtml(getClassFilter()) + ' builds added yet.</div>';
        return;
      }

      let rows = filteredBuilds.map(b => ({ b, s: buildScore(b) }));
      if (playableOnly) rows = rows.filter(r => r.s.playable);
      if (sortByOptimal) rows.sort((a, b) => b.s.optimalPct - a.s.optimalPct);

      out.innerHTML = "";
      for (const { b, s } of rows) {
        const div = document.createElement("div");
        div.className = "build";

        const playableLabel = s.playable ? '<span class="ok">Playable</span>' : '<span class="bad">Not playable</span>';

        div.innerHTML =
          '<h3>' + escapeHtml(b.build) + ' – ' + escapeHtml(b.variant) + '</h3>' +
          '<div class="meta">' + escapeHtml(b.class) + ' • ' + escapeHtml(b.coreSkill) + ' • ' + s.optimalOwned + '/' + s.requiredCount + ' optimal</div>' +
          '<div class="progress">Optimal: ' + s.optimalPct + '%</div>' +
          '<div style="margin-top:6px;">' + playableLabel + '</div>' +
          gearDetailsHtml(b);

        out.appendChild(div);
      }
    }

    function renderInventory() {
      const grid = document.getElementById("invGrid");
      grid.innerHTML = "";

      const filteredBuilds = getFilteredBuilds();
      if (!filteredBuilds.length) {
        grid.innerHTML = '<div class="hint">No ' + escapeHtml(getClassFilter()) + ' items yet (add builds for this class to populate the item list).</div>';
        return;
      }

      const catalog = buildItemCatalog(filteredBuilds);

      for (const slot of slots) {
        const wrap = document.createElement("div");
        wrap.className = "slot";

        const items = catalog[slot];
        const countOwned = inventory[slot].size;

        let html = '<label>' + titleCase(slot) + ' <span class="small">(' + countOwned + ' owned)</span></label>';

        if (!items.length) {
          html += '<div class="hint">No items loaded for this slot.</div>';
          wrap.innerHTML = html;
          grid.appendChild(wrap);
          continue;
        }

        html += '<div>';
        for (const item of items) {
          const id = ('cb_' + slot + '_' + item).replaceAll(' ', '_').replaceAll("'", "");
          const checked = inventory[slot].has(item) ? 'checked' : '';
          html +=
            '<div style="display:flex; gap:10px; align-items:flex-start; margin:6px 0;">' +
              '<input type="checkbox" id="' + escapeHtml(id) + '" data-slot="' + escapeHtml(slot) + '" data-item="' + escapeHtml(item) + '" ' + checked + ' />' +
              '<label for="' + escapeHtml(id) + '" style="margin:0; font-weight:600; cursor:pointer;">' + escapeHtml(item) + '</label>' +
            '</div>';
        }
        html += '</div>';

        wrap.innerHTML = html;
        grid.appendChild(wrap);
      }

      grid.querySelectorAll('input[type=checkbox]').forEach(cb => {
        cb.addEventListener('change', (e) => {
          const slot = e.target.getAttribute('data-slot');
          const item = normalizeItemName(e.target.getAttribute('data-item'));
          if (!slot || !item) return;

          if (e.target.checked) inventory[slot].add(item);
          else inventory[slot].delete(item);

          saveInventory(inventory, activeClass);
          renderBuilds();
          renderInventory();
        });
      });
    }

    // Controls
    document.getElementById('clearBtn').addEventListener('click', () => {
      if (confirm('Clear your saved ' + activeClass + ' inventory?')) clearInventory();
    });

    document.getElementById('saveBtn').addEventListener('click', () => {
      saveInventory(inventory, activeClass);
      renderBuilds();
    });

    document.getElementById('showPlayableOnly').addEventListener('change', renderBuilds);
    document.getElementById('sortByOptimal').addEventListener('change', renderBuilds);

    document.getElementById('classFilter').addEventListener('change', () => {
      saveInventory(inventory, activeClass);
      activeClass = getClassFilter();
      inventory = loadInventory(activeClass);
      renderInventory();
      renderBuilds();
    });

    // Init
    renderInventory();
    renderBuilds();
  });
</script>
</body>
</html>
