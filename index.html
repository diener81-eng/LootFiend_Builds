<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Lootborn Build Tracker</title>
  <style>
    :root{
      --bg:#0f1115;
      --panel:#1a1d24;
      --text:#e6e6e6;
      --muted:#b5b5b5;
      --border:#333;
      --ok:#7CFC98;
      --bad:#ff7a7a;
      --warn:#ffd27a;
    }
    body{font-family:system-ui,-apple-system,BlinkMacSystemFont,sans-serif;background:var(--bg);color:var(--text);margin:0;padding:20px;}
    h1,h2,h3{margin:0 0 10px;}
    .container{max-width:1200px;margin:auto;}
    .topbar{display:flex;gap:12px;flex-wrap:wrap;align-items:baseline;justify-content:space-between;margin-bottom:12px;}
    .small{color:var(--muted);font-size:0.92em;}

    .row{display:grid;grid-template-columns:1.1fr 0.9fr;gap:14px;align-items:start;}
    @media (max-width: 980px){.row{grid-template-columns:1fr;}}

    .card{background:var(--panel);padding:14px;border-radius:12px;border:1px solid rgba(255,255,255,0.04);}
    .hint{color:var(--muted);font-size:0.92em;line-height:1.3;}

    .inv-grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(220px,1fr));gap:12px;margin-top:10px;}
    .slot{background:rgba(0,0,0,0.20);border:1px solid rgba(255,255,255,0.08);border-radius:12px;padding:10px;}
    .slot label{display:block;font-weight:700;margin-bottom:6px;}

    button{cursor:pointer;background:#222738;color:var(--text);border:1px solid rgba(255,255,255,0.10);border-radius:10px;padding:10px 12px;font-weight:700;}
    button:hover{filter:brightness(1.08);}
    button:active{transform:translateY(1px);}
    .btn-row{display:flex;gap:10px;flex-wrap:wrap;margin-top:10px;}

    .toggle-row{display:flex;gap:10px;flex-wrap:wrap;align-items:center;margin-top:10px;}
    .toggle-row label{display:inline-flex;gap:8px;align-items:center;color:var(--muted);font-size:0.92em;user-select:none;}
    select{background:var(--bg);color:var(--text);border:1px solid var(--border);border-radius:8px;padding:6px 8px;}

    .build{background:rgba(0,0,0,0.20);border:1px solid rgba(255,255,255,0.08);padding:14px;border-radius:12px;margin-bottom:12px;}
    .meta{color:var(--muted);font-size:0.92em;margin-top:-6px;margin-bottom:8px;}
    .progress{font-weight:900;}
    .ok{color:var(--ok);font-weight:900;}
    .bad{color:var(--bad);font-weight:900;}
    .warn{color:var(--warn);font-weight:900;}
    details{margin-top:10px;}
    summary{cursor:pointer;color:var(--muted);}
    ul{margin:8px 0 0 18px;padding:0;}
    li{margin:4px 0;}
  </style>
</head>
<body>
  <div class="container">
    <div class="topbar">
      <h1>Lootborn Build Tracker v1.9</h1>
      <div class="small">Saves in your browser (no login). Arcanist and Savage inventories are stored separately.</div>
    </div>

    <div class="row">
      <div class="card">
        <h2>Your Inventory</h2>
        <div class="hint">
          Check the items you own. This list is auto-generated from all items used in the builds (including substitutes).
          Your selections save automatically in your browser, separately for Arcanist vs Savage.
        </div>

        <div class="btn-row">
          <button id="saveBtn">Save now</button>
          <button id="clearBtn" title="Clears the selected class inventory only">Clear inventory (this class)</button>
        </div>

        <div class="inv-grid" id="invGrid"></div>
      </div>

      <div class="card">
        <h2>Builds you are closest to</h2>
        <div class="toggle-row">
          <label><input type="checkbox" id="showPlayableOnly" /> Show playable only</label>
          <label><input type="checkbox" id="sortByOptimal" checked /> Sort by optimal percent</label>
          <label>Class
            <select id="classFilter">
              <option value="Arcanist" selected>Arcanist</option>
              <option value="Savage">Savage</option>
            </select>
          </label>
        </div>
        <div id="buildResults" style="margin-top:12px;"></div>
      </div>
    </div>
  </div>

<script>
  // Version marker: bump this each revision so you can confirm the live site updated.
  const VERSION = "1.9";

  window.addEventListener("DOMContentLoaded", () => {
    const slots = [
      "weapon","helmet","cuirass","belt","greaves","pauldron",
      "bracers","gauntlet","boots","necklace","amulet","ring"
    ];

    const WIKI_BASE = "https://lootbornwarriors.miraheze.org/wiki/";

    // --- Separate storage per class ---
    const STORAGE_KEY_PREFIX = "lootborn_inventory_checkboxes_v2";
    function storageKeyFor(cls) {
      return `${STORAGE_KEY_PREFIX}_${String(cls || "").toLowerCase()}`;
    }

    // Builds: add more objects here as you paste them in.
    const builds = [
      {
        class: "Arcanist",
        coreSkill: "Fireball",
        build: "Iceflame",
        variant: "PvE",
        gear: {
          weapon: "Fate Intertwined",
          helmet: "Evil Spirit Skull",
          cuirass: "Void Cavity",
          belt: "Resurrection",
          greaves: "Void Hip",
          pauldron: "Fairy Whisper",
          bracers: "Dragon Roar Mark",
          gauntlet: "Void Arm",
          boots: "Void Shin",
          necklace: "Balance Chain",
          amulet: "End's Return",
          ring: "Swift Shadow Finger"
        },
        alternatives: {
          boots: ["Planar Shortcut"],
          amulet: ["Overflow Amulet"],
          belt: ["Viper Bond"]
        }
      },
      {
        class: "Arcanist",
        coreSkill: "Fireball",
        build: "Iceflame",
        variant: "Ancient God PvE",
        gear: {
          weapon: "Ancient God's Call",
          helmet: "Dragon Claw Visage",
          cuirass: "Dragon Bone Armor",
          belt: "Dragon Soul Smile",
          greaves: "Dragon Spine Leggings",
          pauldron: "Fairy Whisper",
          bracers: "Dragon Roar Mark",
          gauntlet: "Dragon Fury Grip",
          boots: "Dragon Hyun Walker",
          necklace: "Temporal Pendant",
          amulet: "End's Return",
          ring: "Swift Shadow Finger"
        },
        alternatives: {
          amulet: ["Overflow Amulet"]
        }
      },
      {
        class: "Arcanist",
        coreSkill: "Fireball",
        build: "Pyroblast",
        variant: "PvE",
        gear: {
          weapon: "Fate Intertwined",
          helmet: "Dragon Claw Visage",
          cuirass: "Dragon Bone Armor",
          belt: "Dragon Soul Smile",
          greaves: "Dragon Spine Leggings",
          pauldron: "Void Scapula",
          bracers: "Dragon Roar Mark",
          gauntlet: "Void Arm",
          boots: "Void Shin",
          necklace: "Balance Chain",
          amulet: "End's Return",
          ring: "Swift Shadow Finger"
        },
        alternatives: {
          gauntlet: ["Firm Grip"],
          amulet: ["Holy Shelter"]
        }
      },
      {
        class: "Arcanist",
        coreSkill: "Fireball",
        build: "Pyroblast",
        variant: "Ancient God PvE",
        gear: {
          weapon: "Fate Intertwined",
          helmet: "Dragon Claw Visage",
          cuirass: "Dragon Bone Armor",
          belt: "Dragon Soul Smile",
          greaves: "Dragon Spine Leggings",
          pauldron: "Fairy Whisper",
          bracers: "Dragon Roar Mark",
          gauntlet: "Dragon Fury Grip",
          boots: "Void Shin",
          necklace: "Temporal Pendant",
          amulet: "End's Return",
          ring: "Swift Shadow Finger"
        },
        alternatives: {
          greaves: ["Pack Binding"],
          gauntlet: ["Void Arm"],
          amulet: ["Holy Shelter"]
        }
      },
      {
        class: "Arcanist",
        coreSkill: "Fireball",
        build: "Pyroblast",
        variant: "PvP",
        gear: {
          weapon: "Fate Intertwined",
          helmet: "Dragon Claw Visage",
          cuirass: "Dragon Bone Armor",
          belt: "Dragon Soul Smile",
          greaves: "Dragon Spine Leggings",
          pauldron: "Void Scapula",
          bracers: "Dragon Roar Mark",
          gauntlet: "Void Arm",
          boots: "Planar Shortcut",
          necklace: "Balance Chain",
          amulet: "End's Return",
          ring: "Swift Shadow Finger"
        },
        alternatives: {
          gauntlet: ["Firm Grip"],
          amulet: ["Threshold Mark"]
        }
      },
      {
        class: "Arcanist",
        coreSkill: "Fireball",
        build: "Jolt",
        variant: "PvE Ancient God",
        gear: {
          weapon: "Ancient God Call",
          helmet: "Dragon Claw Visage",
          cuirass: "Dragon Bone Armor",
          belt: "Dragon Soul Smile",
          greaves: "Dragon Spine Leggings",
          pauldron: "Dragon Scale Pauldrons",
          bracers: "Enigmatic Imprint",
          gauntlet: "Void Arm",
          boots: "Dragon Hyun Walker",
          necklace: "Temporal Pendant",
          amulet: "End's Return",
          ring: "Swift Shadow Finger"
        },
        alternatives: {
          amulet: ["Holy Shelter"],
          boots: ["Void Shin"]
        }
      },
      {
        class: "Arcanist",
        coreSkill: "Lightning Punch",
        build: "Ice Sword",
        variant: "PvE",
        gear: {
          weapon: "Fate Intertwined",
          helmet: "Evil Spirit Skull",
          cuirass: "Fate Weaver's Protection",
          belt: "Viper Bond",
          greaves: "Fate Weaver's Desire",
          pauldron: "Fairy Whisper",
          bracers: "Stellar Spindle",
          gauntlet: "Void Arm",
          boots: "Void Shin",
          necklace: "Balance Chain",
          amulet: "End's Return",
          ring: "Swift Shadow Finger"
        },
        alternatives: {
          pauldron: ["Elemental Disruption", "Void Scapula"],
          weapon: ["Sage's Tear"]
        }
      },
      {
        class: "Arcanist",
        coreSkill: "Lightning Punch",
        build: "Ice Sword",
        variant: "PvP",
        gear: {
          weapon: "Prism",
          helmet: "Fate Weaver's Kindness",
          cuirass: "Fate Weaver's Protection",
          belt: "Viper Bond",
          greaves: "Pact Binding",
          pauldron: "Elemental Disruption",
          bracers: "Stellar Spindle",
          gauntlet: "Void Arm",
          boots: "Planar Shortcut",
          necklace: "Balance Chain",
          amulet: "End's Return",
          ring: "Swift Shadow Finger"
        },
        alternatives: {
          boots: ["Scholar's Journey"],
          bracers: ["Enigmatic Imprint"],
          weapon: ["Fate Intertwined"],
          belt: ["Void Abdomen"]
        }
      },
      {
        class: "Arcanist",
        coreSkill: "Lightning Punch",
        build: "Flame Bow",
        variant: "PvE",
        gear: {
          weapon: "Fate Intertwined",
          helmet: "Evil Spirit Skull",
          cuirass: "Void Cavity",
          belt: "Resurrection",
          greaves: "Fate Weaver's Desire",
          pauldron: "Fate Weaver's Mercy",
          bracers: "Stellar Spindle",
          gauntlet: "Void Arm",
          boots: "Void Shin",
          necklace: "Balance Chain",
          amulet: "End's Return",
          ring: "Lucky Echo"
        },
        alternatives: {
          boots: ["Planar Shortcut"],
          ring: ["Swift Shadow Finger"]
        }
      },
      {
        class: "Arcanist",
        coreSkill: "Lightning Punch",
        build: "Thunder Punch",
        variant: "PvE",
        gear: {
          weapon: "Fate Intertwined",
          helmet: "Fate Weaver's Kindness",
          cuirass: "Fel Heritage Robe",
          belt: "Viper Bond",
          greaves: "Fate Weaver's Desire",
          pauldron: "Elemental Disruption",
          bracers: "Stellar Spindle",
          gauntlet: "Void Arm",
          boots: "Void Shin",
          necklace: "Balance Chain",
          amulet: "End's Return",
          ring: "Swift Shadow Finger"
        },
        alternatives: {
          boots: ["Planar Shortcut"],
          amulet: ["Threshold Mark"]
        }
      },
      {
        class: "Arcanist",
        coreSkill: "Lightning Punch",
        build: "Thunder Punch",
        variant: "PvP",
        gear: {
          weapon: "Fate Intertwined",
          helmet: "Fate Weaver's Kindness",
          cuirass: "Fate Weaver's Protection",
          belt: "Fate Weaver's Taking",
          greaves: "Fate Weaver's Desire",
          pauldron: "Fate Weaver's Mercy",
          bracers: "Stellar Spindle",
          gauntlet: "Void Arm",
          boots: "Fate Weaver's Benevolence",
          necklace: "Balance Chain",
          amulet: "Threshold Mark",
          ring: "Swift Shadow Finger"
        },
        alternatives: {
          necklace: ["Swoosh"],
          amulet: ["Splash"],
          ring: ["Hiss"],
          cuirass: ["Fel Heritage Robe"]
        }
      },
      {
        class: "Arcanist",
        coreSkill: "Ice Ray",
        build: "Rimebite",
        variant: "PvE",
        gear: {
          weapon: "Lich Remains",
          helmet: "Evil Spirit Skull",
          cuirass: "Cryo Mark Robe",
          belt: "Viper Bond",
          greaves: "Cryo Mark Trousers",
          pauldron: "Void Scapula",
          bracers: "Sorrow Bracers",
          gauntlet: "Cryo Mark Gloves",
          boots: "Cryo Mark Boots",
          necklace: "Temporal Pendant",
          amulet: "Holy Shelter",
          ring: "Winter Guard"
        },
        alternatives: {
          necklace: ["Balance Chain"],
          pauldron: ["Fairy Whisper"],
          ring: ["Swift Shadow Finger"]
        }
      },
      {
        class: "Arcanist",
        coreSkill: "Ice Ray",
        build: "Rimebite",
        variant: "PvP",
        gear: {
          weapon: "Fate Intertwined",
          helmet: "Cryo Mark Crown",
          cuirass: "Cryo Mark Robe",
          belt: "Cryo Mark Waistband",
          greaves: "Cryo Mark Trousers",
          pauldron: "Fairy Whisper",
          bracers: "Sorrow Bracers",
          gauntlet: "Deathspeaker",
          boots: "Planar Shortcut",
          necklace: "Swoosh",
          amulet: "Splash",
          ring: "Hiss"
        },
        alternatives: {}
      },
      {
        class: "Arcanist",
        coreSkill: "Ice Ray",
        build: "Pyresight",
        variant: "PvE",
        gear: {
          weapon: "Lich Remains",
          helmet: "Cryo Mark Crown",
          cuirass: "Void Cavity",
          belt: "Resurrection",
          greaves: "Cryo Mark Trousers",
          pauldron: "Cryo Mark Pauldrons",
          bracers: "Sorrow Bracers",
          gauntlet: "Void Arm",
          boots: "Cryo Mark Boots",
          necklace: "Temporal Pendant",
          amulet: "Threshold Mark",
          ring: "Swift Shadow Finger"
        },
        alternatives: {
          weapon: ["Fate Intertwined"],
          necklace: ["Balance Chain"],
          ring: ["Winter Guard"]
        }
      },
      {
        class: "Arcanist",
        coreSkill: "Ice Ray",
        build: "Ionization",
        variant: "PvE",
        gear: {
          weapon: "Lich Remains",
          helmet: "Cryo Mark Crown",
          cuirass: "Fel Heritage Robe",
          belt: "Cryo Mark Waistband",
          greaves: "Cryo Mark Trousers",
          pauldron: "Cryo Mark Pauldrons",
          bracers: "Sorrow Bracers",
          gauntlet: "Void Arm",
          boots: "Void Shin",
          necklace: "Balance Chain",
          amulet: "Threshold Mark",
          ring: "Swift Shadow Finger"
        },
        alternatives: {}
      }
    ];

    function titleCase(s) {
      if (!s) return "";
      return s.charAt(0).toUpperCase() + s.slice(1);
    }

    function escapeHtml(str) {
      return String(str)
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;")
        .replaceAll('"', "&quot;")
        .replaceAll("'", "&#039;");
    }

    function wikiUrlForBuild(buildName) {
      const slug = String(buildName || "").trim().split(" ").filter(Boolean).join("_");
      return WIKI_BASE + encodeURIComponent(slug);
    }

    function getClassFilter() {
      const el = document.getElementById("classFilter");
      return el ? el.value : "Arcanist";
    }

    function getFilteredBuilds() {
      const cf = getClassFilter();
      return builds.filter(b => b.class === cf);
    }

    // ---- Inventory state (by slot: Set of owned items) ----
    function emptyInventory() {
      const inv = {};
      for (const slot of slots) inv[slot] = new Set();
      return inv;
    }

    function loadInventory(cls) {
      const inv = emptyInventory();
      try {
        const raw = localStorage.getItem(storageKeyFor(cls));
        if (!raw) return inv;
        const obj = JSON.parse(raw);
        for (const slot of slots) {
          const arr = obj && obj[slot];
          if (Array.isArray(arr)) {
            for (const it of arr) inv[slot].add(String(it).trim());
          }
        }
      } catch (e) {}
      return inv;
    }

    function saveInventory(inv, cls) {
      const obj = {};
      for (const slot of slots) obj[slot] = Array.from(inv[slot]);
      localStorage.setItem(storageKeyFor(cls), JSON.stringify(obj));
    }

    let activeClass = getClassFilter();
    let inventory = loadInventory(activeClass);

    function clearInventory() {
      inventory = emptyInventory();
      saveInventory(inventory, activeClass);
      renderInventory();
      renderBuilds();
    }

    // ---- Build the item catalog (by slot) from the selected class builds ----
    function buildItemCatalog(filteredBuilds) {
      const bySlot = {};
      for (const slot of slots) bySlot[slot] = [];

      for (const b of filteredBuilds) {
        for (const slot of slots) {
          const req = b.gear && b.gear[slot];
          if (req) bySlot[slot].push(req);
          const alts = (b.alternatives && b.alternatives[slot]) ? b.alternatives[slot] : [];
          for (const a of alts) bySlot[slot].push(a);
        }
      }

      const uniqSorted = {};
      for (const slot of slots) {
        const seen = new Set();
        const out = [];
        for (const it of bySlot[slot]) {
          const item = String(it || "").trim();
          if (!item) continue;
          if (seen.has(item)) continue;
          seen.add(item);
          out.push(item);
        }
        out.sort((a, b) => a.localeCompare(b));
        uniqSorted[slot] = out;
      }

      return uniqSorted;
    }

    // ---- Scoring ----
    function buildScore(build) {
      let requiredCount = 0;
      let optimalOwned = 0;
      let playable = true;

      for (const slot of slots) {
        const required = build.gear && build.gear[slot];
        if (!required) continue;
        requiredCount++;

        if (inventory[slot].has(required)) {
          optimalOwned++;
          continue;
        }

        const alts = (build.alternatives && build.alternatives[slot]) ? build.alternatives[slot] : [];
        const ownedAlt = alts.find(a => inventory[slot].has(a));
        if (!ownedAlt) playable = false;
      }

      const optimalPct = requiredCount ? Math.round((optimalOwned / requiredCount) * 100) : 0;
      return { requiredCount, optimalOwned, optimalPct, playable };
    }

    function buildGearBreakdown(build) {
      const rows = [];
      for (const slot of slots) {
        const req = build.gear && build.gear[slot];
        if (!req) continue;

        const hasReq = inventory[slot].has(req);
        const alts = (build.alternatives && build.alternatives[slot]) ? build.alternatives[slot] : [];
        const ownedAlt = alts.find(a => inventory[slot].has(a));

        rows.push({
          slot,
          required: req,
          status: hasReq ? "owned" : (ownedAlt ? "sub" : "missing"),
          substitute: ownedAlt || ""
        });
      }
      return rows;
    }

    function gearDetailsHtml(build) {
      const rows = buildGearBreakdown(build);
      const wiki = wikiUrlForBuild(build.build);

      let html = `<details><summary>Build details</summary>`;
      html += `<div style="margin-top:8px; display:flex; gap:10px; flex-wrap:wrap; align-items:center;">`;
      html += `<a href="${escapeHtml(wiki)}" target="_blank" rel="noopener" style="color: var(--warn); text-decoration: none; font-weight: 800;">Open wiki page</a>`;
      html += `<span class="small">(opens in new tab)</span>`;
      html += `</div>`;

      html += `<div style="margin-top:10px;"><ul>`;
      for (const r of rows) {
        if (r.status === "owned") {
          html += `<li><span class="ok">✓</span> <b>${escapeHtml(titleCase(r.slot))}</b>: ${escapeHtml(r.required)}</li>`;
        } else if (r.status === "sub") {
          html += `<li><span class="warn">~</span> <b>${escapeHtml(titleCase(r.slot))}</b>: missing ${escapeHtml(r.required)} — using ${escapeHtml(r.substitute)}</li>`;
        } else {
          html += `<li><span class="bad">✗</span> <b>${escapeHtml(titleCase(r.slot))}</b>: ${escapeHtml(r.required)}</li>`;
        }
      }
      html += `</ul></div></details>`;
      return html;
    }

    function renderBuilds() {
      const out = document.getElementById("buildResults");
      const playableOnly = document.getElementById("showPlayableOnly").checked;
      const sortByOptimal = document.getElementById("sortByOptimal").checked;

      const filteredBuilds = getFilteredBuilds();
      if (!filteredBuilds.length) {
        out.innerHTML = `<div class="hint">No ${escapeHtml(getClassFilter())} builds added yet.</div>`;
        return;
      }

      let rows = filteredBuilds.map(b => ({ b, s: buildScore(b) }));
      if (playableOnly) rows = rows.filter(r => r.s.playable);
      if (sortByOptimal) rows.sort((a, b) => b.s.optimalPct - a.s.optimalPct);

      out.innerHTML = "";
      for (const { b, s } of rows) {
        const div = document.createElement("div");
        div.className = "build";

        const playableLabel = s.playable
          ? `<span class="ok">Playable</span>`
          : `<span class="bad">Not playable</span>`;

        div.innerHTML = `
          <h3>${escapeHtml(b.build)} – ${escapeHtml(b.variant)}</h3>
          <div class="meta">${escapeHtml(b.class)} • ${escapeHtml(b.coreSkill)} • ${s.optimalOwned}/${s.requiredCount} optimal</div>
          <div class="progress">Optimal: ${s.optimalPct}%</div>
          <div style="margin-top:6px;">${playableLabel}</div>
          ${gearDetailsHtml(b)}
        `;

        out.appendChild(div);
      }
    }

    function renderInventory() {
      const grid = document.getElementById("invGrid");
      grid.innerHTML = "";

      const filteredBuilds = getFilteredBuilds();
      if (!filteredBuilds.length) {
        grid.innerHTML = `<div class="hint">No ${escapeHtml(getClassFilter())} items yet (add builds for this class to populate the item list).</div>`;
        return;
      }

      const catalog = buildItemCatalog(filteredBuilds);

      for (const slot of slots) {
        const wrap = document.createElement("div");
        wrap.className = "slot";

        const items = catalog[slot];
        const countOwned = inventory[slot].size;

        let html = `<label>${titleCase(slot)} <span class="small">(${countOwned} owned)</span></label>`;

        if (!items.length) {
          html += `<div class="hint">No items loaded for this slot for ${escapeHtml(getClassFilter())}.</div>`;
          wrap.innerHTML = html;
          grid.appendChild(wrap);
          continue;
        }

        html += `<div>`;
        for (const item of items) {
          const id = `cb_${slot}_${item}`.replaceAll(" ", "_").replaceAll("'", "");
          const checked = inventory[slot].has(item) ? "checked" : "";
          html += `
            <div style="display:flex; gap:10px; align-items:flex-start; margin:6px 0;">
              <input type="checkbox" id="${escapeHtml(id)}" data-slot="${escapeHtml(slot)}" data-item="${escapeHtml(item)}" ${checked} />
              <label for="${escapeHtml(id)}" style="margin:0; font-weight:600; cursor:pointer;">${escapeHtml(item)}</label>
            </div>
          `;
        }
        html += `</div>`;

        wrap.innerHTML = html;
        grid.appendChild(wrap);
      }

      grid.querySelectorAll("input[type=checkbox]").forEach(cb => {
        cb.addEventListener("change", (e) => {
          const slot = e.target.getAttribute("data-slot");
          const item = e.target.getAttribute("data-item");
          if (!slot || !item) return;

          if (e.target.checked) inventory[slot].add(item);
          else inventory[slot].delete(item);

          saveInventory(inventory, activeClass);
          renderBuilds();
          renderInventory();
        });
      });
    }

    // Controls
    document.getElementById("clearBtn").addEventListener("click", () => {
      if (confirm(`Clear your saved ${activeClass} inventory?`)) clearInventory();
    });

    document.getElementById("saveBtn").addEventListener("click", () => {
      saveInventory(inventory, activeClass);
      renderBuilds();
    });

    document.getElementById("showPlayableOnly").addEventListener("change", renderBuilds);
    document.getElementById("sortByOptimal").addEventListener("change", renderBuilds);

    document.getElementById("classFilter").addEventListener("change", () => {
      // Save current class inventory, switch contexts, then load the other class inventory
      saveInventory(inventory, activeClass);
      activeClass = getClassFilter();
      inventory = loadInventory(activeClass);
      renderInventory();
      renderBuilds();
    });

    // Init
    renderInventory();
    renderBuilds();
  });
</script>
</body>
</html>
